import{_ as t,r as s,o as n,c as i,a as e,d as r,b as c,e as o}from"./app-66d6b4fd.js";const p="/blog/mq/rocketmq/Snipaste_2023-06-22_14-49-28.png",h="/blog/mq/rocketmq/Snipaste_2023-06-22_14-51-53.png",d="/blog/mq/rocketmq/Snipaste_2023-06-22_15-00-51.png",l={},u=o('<h1 id="rocketmq简介" tabindex="-1"><a class="header-anchor" href="#rocketmq简介" aria-hidden="true">#</a> RocketMQ简介</h1><p>RocketMQ 是一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。同时，广泛应用于多个领域，包括异步通信解耦、企业解决方案、金融支付、电信、电子商务、快递物流、广告营销、社交、即时通信、移动应用、手游、视频、物联网、车联网等。</p><p>具有以下特点：</p><ul><li>能够保证严格的消息顺序</li><li>提供丰富的消息拉取模式</li><li>高效的订阅者水平扩展能力</li><li>实时的消息订阅机制</li><li>亿级消息堆积能力</li><li>Metaq3.0 版本改名，产品名称改为 RocketMQ</li></ul>',4),m={class:"custom-container tip"},k=e("p",{class:"custom-container-title"},"提示",-1),g=e("strong",null,"官方文档",-1),_={href:"https://rocketmq.apache.org/zh/docs/",target:"_blank",rel:"noopener noreferrer"},S=o('<h2 id="_1-初识rocketmq" tabindex="-1"><a class="header-anchor" href="#_1-初识rocketmq" aria-hidden="true">#</a> 1.初识RocketMQ</h2><p>我们平时使用一些体育新闻软件，会订阅自己喜欢的一些球队板块，当有作者发表文章到相关的板块，我们就能收到相关的新闻推送。</p><p>发布-订阅（Pub/Sub）是一种消息范式，消息的发送者（称为发布者、生产者、Producer）会将消息直接发送给特定的接收者（称为订阅者、消费者、Comsumer）。而RocketMQ的基础消息模型就是一个简单的Pub/Sub模型。</p><p><strong>相关概念</strong></p><p><strong>生产者</strong>：负责生产消息，一般由业务系统负责生产消息。一个消息生产者会把业务应用系统里产生的消息发送到broker服务器。RocketMQ提供多种发送方式，同步发送、异步发送、顺序发送、单向发送。</p><p><strong>消费者</strong>：负责消费消息，一般是后台系统负责异步消费。一个消息消费者会从Broker服务器拉取消息、并将其提供给应用程序。从用户应用的角度而言提供了两种消费形式：拉取式消费、推动式消费。</p><p><strong>主题</strong>：表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。</p><h3 id="_1-1rocketmq基础消息模型" tabindex="-1"><a class="header-anchor" href="#_1-1rocketmq基础消息模型" aria-hidden="true">#</a> 1.1RocketMQ基础消息模型</h3><p>RocketMQ的基础消息模型，是一个简单的Pub/Sub模型。</p><p><img src="'+p+'" alt="Snipaste_2023-06-22_14-49-28"></p><p>上图就是一个基本的消息系统模型，包括<strong>生产者 (Producer)</strong>，<strong>消费者 (Consumer)</strong>，中间进行基于**消息主题（Topic）**的消息传送。</p><p>在<strong>基于主题</strong>的系统中，消息被发布到主题或命名通道上。消费者将收到其订阅主题上的所有消息，生产者负责定义订阅者所订阅的消息类别。这是一个基础的概念模型，而在实际的应用中，结构会更复杂。例如为了支持高并发和水平扩展，中间的消息主题需要进行分区，同一个Topic会有多个生产者，同一个信息会有多个消费者，消费者之间要进行负载均衡等。</p><h3 id="_1-2rocketmq扩展后的消息模型" tabindex="-1"><a class="header-anchor" href="#_1-2rocketmq扩展后的消息模型" aria-hidden="true">#</a> 1.2RocketMQ扩展后的消息模型</h3><p><img src="'+h+'" alt="Snipaste_2023-06-22_14-51-53"></p><p>上图就是一个扩展后的消息模型，包括<strong>两个生产者</strong>，<strong>两个消息Topic</strong>，以及<strong>两组消费者 Comsumer</strong>。存储消息Topic的 <strong>代理服务器</strong>( <strong>Broker</strong> )，是实际部署过程对应的代理服务器。</p><ul><li><p>为了消息写入能力的<strong>水平扩展</strong>，RocketMQ 对 Topic进行了分区，这种操作被称为<strong>队列</strong>（MessageQueue）。</p></li><li><p>为了消费能力的<strong>水平扩展</strong>，ConsumerGroup的概念应运而生。</p></li></ul><p><strong>信息</strong></p><ul><li><p>相同的ConsumerGroup下的消费者主要有两种负载均衡模式，即<strong>广播模式</strong>，和<strong>集群模式</strong>（图中是最常用的集群模式）。</p></li><li><p>在集群模式下，同一个 ConsumerGroup 中的 Consumer 实例是负载均衡消费，如图中 ConsumerGroupA 订阅 TopicA，TopicA 对应 3个队列，则 GroupA 中的 Consumer1 消费的是 MessageQueue 0和 MessageQueue 1的消息，Consumer2是消费的是MessageQueue2的消息。</p></li><li><p>在广播模式下，同一个 ConsumerGroup 中的每个 Consumer 实例都处理全部的队列。需要注意的是，广播模式下因为每个 Consumer 实例都需要处理全部的消息，因此这种模式仅推荐在通知推送、配置同步类小流量场景使用。</p></li></ul><h3 id="_1-3rocketmq部署模型" tabindex="-1"><a class="header-anchor" href="#_1-3rocketmq部署模型" aria-hidden="true">#</a> 1.3RocketMQ部署模型</h3><p>Producer、Consumer又是如何找到Topic和Broker的地址呢？消息的具体发送和接收又是怎么进行的呢？</p><p><img src="'+d+'" alt="Snipaste_2023-06-22_15-00-51"></p><p>Apache RocketMQ 部署架构上主要分为四部分:</p><h4 id="生产者-producer" tabindex="-1"><a class="header-anchor" href="#生产者-producer" aria-hidden="true">#</a> 生产者 Producer</h4><p>发布消息的角色。Producer通过 MQ 的负载均衡模块选择相应的 Broker 集群队列进行消息投递，投递的过程支持快速失败和重试。</p><h4 id="消费者-consumer" tabindex="-1"><a class="header-anchor" href="#消费者-consumer" aria-hidden="true">#</a> 消费者 Consumer</h4><p>消息消费的角色。</p><ul><li>支持以推（push），拉（pull）两种模式对消息进行消费。</li><li>同时也支持<strong>集群方式</strong>和广播方式的消费。</li><li>提供实时消息订阅机制，可以满足大多数用户的需求。</li></ul><h4 id="名字服务器-nameserver" tabindex="-1"><a class="header-anchor" href="#名字服务器-nameserver" aria-hidden="true">#</a> 名字服务器 NameServer</h4><p>NameServer是一个简单的 Topic 路由注册中心，支持 Topic、Broker 的动态注册与发现。</p><p>主要包括两个功能：</p><ul><li><p><strong>Broker管理</strong>，NameServer接受Broker集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查Broker是否还存活；</p></li><li><p><strong>路由信息管理</strong>，每个NameServer将保存关于 Broker 集群的整个路由信息和用于客户端查询的队列信息。Producer和Consumer通过NameServer就可以知道整个Broker集群的路由信息，从而进行消息的投递和消费。</p></li></ul><p>NameServer通常会有多个实例部署，各实例间相互不进行信息通讯。Broker是向每一台NameServer注册自己的路由信息，所以每一个NameServer实例上面都保存一份完整的路由信息。当某个NameServer因某种原因下线了，客户端仍然可以向其它NameServer获取路由信息。</p><h4 id="代理服务器-broker" tabindex="-1"><a class="header-anchor" href="#代理服务器-broker" aria-hidden="true">#</a> 代理服务器 Broker</h4><p>Broker主要负责消息的存储、投递和查询以及服务高可用保证。</p><p>NameServer几乎无状态节点，因此可集群部署，节点之间无任何信息同步。Broker部署相对复杂。</p><p>在 Master-Slave 架构中，Broker 分为 Master 与 Slave。一个Master可以对应多个Slave，但是一个Slave只能对应一个Master。Master 与 Slave 的对应关系通过指定相同的BrokerName，不同的BrokerId 来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。</p><h4 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h4><ul><li>每个 <strong>Broker</strong> 与 <strong>NameServer</strong> 集群中的所有节点建立长连接，定时注册 Topic 信息到所有 NameServer。</li><li><strong>Producer</strong> 与 <strong>NameServer</strong> 集群中的其中一个节点建立长连接，定期从 NameServer 获取Topic路由信息，并向提供 Topic 服务的 Master 建立长连接，且定时向 Master 发送心跳。Producer 完全无状态。</li><li><strong>Consumer</strong> 与 <strong>NameServer</strong> 集群中的其中一个节点建立长连接，定期从 NameServer 获取 Topic 路由信息，并向提供 Topic 服务的 Master、Slave 建立长连接，且定时向 Master、Slave发送心跳。Consumer 既可以从 Master 订阅消息，也可以从Slave订阅消息。</li></ul><h3 id="_1-4rocketmq集群工作流程" tabindex="-1"><a class="header-anchor" href="#_1-4rocketmq集群工作流程" aria-hidden="true">#</a> 1.4RocketMQ集群工作流程</h3><h4 id="_1-启动nameserver" tabindex="-1"><a class="header-anchor" href="#_1-启动nameserver" aria-hidden="true">#</a> 1）启动NameServer</h4><p>启动NameServer。NameServer启动后监听端口，等待Broker、Producer、Consumer连接，相当于一个路由控制中心。</p><h4 id="_2-启动-broker" tabindex="-1"><a class="header-anchor" href="#_2-启动-broker" aria-hidden="true">#</a> 2）启动 Broker</h4><p>启动 Broker。与所有 NameServer 保持长连接，定时发送心跳包。心跳包中包含当前 Broker 信息以及存储所有 Topic 信息。注册成功后，NameServer 集群中就有 Topic跟Broker 的映射关系。</p><h4 id="_3-创建-topic" tabindex="-1"><a class="header-anchor" href="#_3-创建-topic" aria-hidden="true">#</a> 3）创建 Topic</h4><p>创建 Topic 时需要指定该 Topic 要存储在哪些 Broker 上，也可以在发送消息时自动创建Topic。</p><h4 id="_4-生产者发送消息" tabindex="-1"><a class="header-anchor" href="#_4-生产者发送消息" aria-hidden="true">#</a> 4）生产者发送消息</h4><p>生产者发送消息。启动时先跟 NameServer 集群中的其中一台建立长连接，并从 NameServer 中获取当前发送的 Topic存在于哪些 Broker 上，轮询从队列列表中选择一个队列，然后与队列所在的 Broker建立长连接从而向 Broker发消息。</p><h4 id="_5-消费者接受消息" tabindex="-1"><a class="header-anchor" href="#_5-消费者接受消息" aria-hidden="true">#</a> 5）消费者接受消息</h4><p>消费者接受消息。跟其中一台NameServer建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，然后开始消费消息。</p>',49);function v(M,B){const a=s("ExternalLinkIcon");return n(),i("div",null,[u,e("div",m,[k,e("p",null,[g,r("："),e("a",_,[r("RocketMQ 5.0"),c(a)])])]),S])}const N=t(l,[["render",v],["__file","RocketMQ简介.html.vue"]]);export{N as default};
