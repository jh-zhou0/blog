import{_ as t,o as d,c as a,e}from"./app-66d6b4fd.js";const i="/blog/mq/Snipaste_2023-06-19_14-54-21.png",r="/blog/mq/Snipaste_2023-06-19_15-00-57.png",p={},l=e('<h1 id="消息队列-mq" tabindex="-1"><a class="header-anchor" href="#消息队列-mq" aria-hidden="true">#</a> 消息队列(MQ)</h1><h2 id="_1-初识mq" tabindex="-1"><a class="header-anchor" href="#_1-初识mq" aria-hidden="true">#</a> 1.初识MQ</h2><h3 id="_1-1同步和异步通讯" tabindex="-1"><a class="header-anchor" href="#_1-1同步和异步通讯" aria-hidden="true">#</a> 1.1同步和异步通讯</h3><p>微服务间通讯有同步和异步两种方式：</p><ul><li><p>同步通讯：就像打电话，需要实时响应。</p></li><li><p>异步通讯：就像发邮件，不需要马上回复。</p></li></ul><p>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。</p><h4 id="同步通讯" tabindex="-1"><a class="header-anchor" href="#同步通讯" aria-hidden="true">#</a> 同步通讯</h4><p>Feign调用就属于同步方式，虽然调用可以实时得到结果，但存在下面的问题：</p><p><img src="'+i+'" alt="Snipaste_2023-06-19_14-54-21"></p><p><strong>总结</strong>：</p><p>同步调用的优点：</p><ul><li>时效性较强，可以立即得到结果</li></ul><p>同步调用的问题：</p><ul><li>耦合度高</li><li>性能和吞吐能力下降</li><li>有额外的资源消耗</li><li>有级联失败问题</li></ul><h4 id="异步通讯" tabindex="-1"><a class="header-anchor" href="#异步通讯" aria-hidden="true">#</a> 异步通讯</h4><p>异步调用则可以避免上述问题。</p><p>以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。</p><p>在事件模式中，支付服务是事件发布者（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单id。</p><p>订单服务和物流服务是事件订阅者（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。</p><p>为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。</p><p><img src="'+r+'" alt="Snipaste_2023-06-19_15-00-57"></p><p>好处：</p><ul><li><p>吞吐量提升：无需等待订阅者处理完成，响应更快速</p></li><li><p>故障隔离：服务没有直接调用，不存在级联失败问题</p></li><li><p>调用间没有阻塞，不会造成无效的资源占用</p></li><li><p>耦合度极低，每个服务都可以灵活插拔，可替换</p></li><li><p>流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件</p></li></ul><p>缺点：</p><ul><li>架构复杂了，业务没有明显的流程线，不好管理</li><li>需要依赖于Broker的可靠、安全、性能</li></ul><h3 id="_1-2技术对比" tabindex="-1"><a class="header-anchor" href="#_1-2技术对比" aria-hidden="true">#</a> 1.2技术对比</h3><p>MQ，中文是消息队列（MessageQueue），字面来看就是存放消息的队列。也就是事件驱动架构中的Broker。</p><p>比较常见的MQ实现：</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul><table><thead><tr><th></th><th><strong>RabbitMQ</strong></th><th><strong>ActiveMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td>公司/社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire,STOMP，REST,XMPP,AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>可用性</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>单机吞吐量</td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr><tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p><p>追求可靠性：RabbitMQ、RocketMQ</p><p>追求吞吐能力：RocketMQ、Kafka</p><p>追求消息低延迟：RabbitMQ、Kafka</p>',34),h=[l];function n(o,s){return d(),a("div",null,h)}const _=t(p,[["render",n],["__file","index.html.vue"]]);export{_ as default};
